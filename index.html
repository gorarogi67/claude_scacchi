<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Host</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 800px;
            width: 95%;
            margin: 20px;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #555;
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input[type="password"], input[type="email"], input[type="text"], input[type="url"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #6c757d;
            margin-left: 10px;
        }

        .btn-danger {
            background: #dc3545;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 0;
            margin: 20px auto;
            border: 3px solid #333;
            border-radius: 5px;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .square.white {
            background-color: #f0d9b5;
        }

        .square.black {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fb800 !important;
        }

        .square.highlight {
            background-color: #ffff99 !important;
        }

        .square.possible-move {
            box-shadow: inset 0 0 0 3px #7fb800;
        }

        .square.possible-capture {
            background: radial-gradient(circle, #ff4444, #cc0000) !important;
            box-shadow: inset 0 0 0 3px #ff0000, 0 0 15px rgba(255, 68, 68, 0.8);
            animation: flame 1.5s ease-in-out infinite alternate;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="20" font-size="20" fill="gold">‚öîÔ∏è</text></svg>') 16 16, pointer;
        }

        @keyframes flame {
            0% { 
                box-shadow: inset 0 0 0 3px #ff0000, 0 0 15px rgba(255, 68, 68, 0.8);
                transform: scale(1);
            }
            50% {
                box-shadow: inset 0 0 0 3px #ff6600, 0 0 20px rgba(255, 102, 0, 0.9);
                transform: scale(1.05);
            }
            100% { 
                box-shadow: inset 0 0 0 3px #ff0000, 0 0 25px rgba(255, 0, 0, 1);
                transform: scale(1.02);
            }
        }

        .square.not-playable {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .square.not-playable:hover {
            transform: none;
        }

        .game-info {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .current-player {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .game-link {
            background: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            word-break: break-all;
            margin: 10px 0;
        }

        .moves-history {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .player-names {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .white-player {
            color: #333;
        }

        .black-player {
            color: #666;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        @media (max-width: 600px) {
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }

            .square {
                width: 45px;
                height: 45px;
                font-size: 30px;
            }

            .container {
                padding: 20px;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        small {
            display: block;
            margin-top: 5px;
        }

        /* Modal Promozione Pedone */
        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-modal.active {
            display: flex;
        }

        .promotion-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from { 
                opacity: 0;
                transform: scale(0.8);
            }
            to { 
                opacity: 1;
                transform: scale(1);
            }
        }

        .promotion-pieces {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
        }

        .promotion-piece {
            width: 80px;
            height: 80px;
            font-size: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            border: 3px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .promotion-piece:hover {
            background: #e0e0ff;
            border-color: #667eea;
            transform: scale(1.1);
        }

        /* Nuovo stile per link corti Firebase */
        .firebase-info {
            background: linear-gradient(135deg, #00c9ff 0%, #92fe9d 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }

        .connection-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin: 5px;
        }

        .connection-online {
            background: #28a745;
            color: white;
        }

        .connection-offline {
            background: #dc3545;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Schermata Login Amministratore -->
        <div id="admin-login" class="screen active">
            <h1>üè∞ Chess Host</h1>
            <h2>Accesso Amministratore</h2>
            <div class="firebase-info">
                <strong>üöÄ Versione Firebase!</strong><br>
                URL Super-Corti ‚Ä¢ Partite Permanenti ‚Ä¢ Cross-Device
            </div>
            <div class="form-group">
                <label for="admin-password">Password Amministratore:</label>
                <input type="password" id="admin-password" placeholder="Inserisci la password">
            </div>
            <button class="btn" onclick="adminLogin()">Accedi</button>
            <div id="login-message"></div>
            <div class="connection-status" id="firebase-status">üîó Connessione Firebase...</div>
        </div>

        <!-- Pannello Controllo Amministratore -->
        <div id="admin-panel" class="screen">
            <h1>üéÆ Pannello Amministratore</h1>
            <div class="firebase-info">
                <strong>üî• Firebase Attivo!</strong><br>
                <span id="firebase-connection">Controllo connessione...</span>
            </div>
            <div class="form-group">
                <label for="white-player">Nome Giocatore Bianco:</label>
                <input type="text" id="white-player" value="Bianco" placeholder="Nome giocatore bianco">
            </div>
            <div class="form-group">
                <label for="black-player">Nome Giocatore Nero:</label>
                <input type="text" id="black-player" value="Nero" placeholder="Nome giocatore nero">
            </div>
            <button class="btn" onclick="createGame()">Crea Partita</button>
            <button class="btn btn-secondary" onclick="showGameIfExists()">Visualizza Partita Attiva</button>
            <button class="btn btn-danger" onclick="resetGame()">Reset Partita</button>
            <button class="btn btn-secondary" onclick="logout()">Logout</button>
            <div id="admin-message"></div>
        </div>

        <!-- Schermata Partita -->
        <div id="game-screen" class="screen">
            <h1>‚ôî Chess Host</h1>
            <div class="firebase-info">
                <strong>üöÄ Link Super-Corto Firebase!</strong><br>
                <small>Partita permanente ‚Ä¢ Sincronizzazione real-time ‚Ä¢ Cross-device</small>
            </div>
            
            <!-- Link Corrente sempre visibile -->
            <div class="game-info" id="current-link-display" style="background: #e7f3ff; border: 2px solid #007bff;">
                <h4 style="margin: 0 0 10px 0; color: #007bff;">üîó Link Partita</h4>
                <input type="text" id="current-game-url" readonly onclick="this.select()" style="width:100%; padding:8px; margin:5px 0; font-family:monospace; background:#ffffff; border:1px solid #007bff; border-radius:4px;">
                <button class="btn" onclick="copyCurrentLink()" style="background: #007bff;">üìã Copia Link</button>
                <p style="margin: 5px 0 0 0; color: #555;" id="url-info"><em>üöÄ URL corto che funziona per sempre!</em></p>
                <div class="connection-status" id="game-firebase-status">üîó Stato connessione...</div>
            </div>

            <div class="player-names">
                <span class="white-player" id="white-name">Bianco</span>
                <span class="black-player" id="black-name">Nero</span>
            </div>
            <div class="game-info">
                <div class="current-player" id="current-turn">Turno del Bianco</div>
                <div id="game-status"></div>
            </div>
            <div class="chess-board" id="chess-board"></div>
            <div class="game-info" id="admin-controls" style="display:none;">
                <h3>Controlli Amministratore</h3>
                <button class="btn" onclick="endGame('white')">Vittoria Bianco</button>
                <button class="btn" onclick="endGame('black')">Vittoria Nero</button>
                <button class="btn" onclick="endGame('draw')">Pareggio</button>
                <button class="btn" onclick="endGame('abandoned')">Abbandono</button>
                <button class="btn btn-danger" onclick="resetGame()">Reset Partita</button>
            </div>
            <div class="moves-history">
                <h4>Cronologia Mosse:</h4>
                <div id="moves-list"></div>
            </div>
        </div>

        <!-- Schermata Caricamento -->
        <div id="loading-screen" class="screen">
            <div class="loading">
                <div class="spinner"></div>
                <p>Caricamento partita da Firebase...</p>
                <p><small>Connessione database in corso...</small></p>
            </div>
        </div>

        <!-- Schermata Errore -->
        <div id="error-screen" class="screen">
            <h1>‚ö†Ô∏è Errore</h1>
            <div class="status-message status-error" id="error-message">
                Link partita non valido o partita non trovata.
            </div>
            <button class="btn" onclick="location.reload()">Ricarica Pagina</button>
        </div>

        <!-- Modal Promozione Pedone -->
        <div id="promotion-modal" class="promotion-modal">
            <div class="promotion-content">
                <h3>üéâ Promozione Pedone!</h3>
                <p>Scegli in quale pezzo trasformare il tuo pedone:</p>
                <div class="promotion-pieces">
                    <div class="promotion-piece" onclick="promoteTopiece('queen')" title="Regina">
                        <span id="promotion-queen">‚ôï</span>
                    </div>
                    <div class="promotion-piece" onclick="promoteTopiece('rook')" title="Torre">
                        <span id="promotion-rook">‚ôñ</span>
                    </div>
                    <div class="promotion-piece" onclick="promoteTopiece('bishop')" title="Alfiere">
                        <span id="promotion-bishop">‚ôó</span>
                    </div>
                    <div class="promotion-piece" onclick="promoteTopiece('knight')" title="Cavallo">
                        <span id="promotion-knight">‚ôò</span>
                    </div>
                </div>
                <p><small>üí° La Regina √® il pezzo pi√π potente, ma ogni pezzo ha i suoi vantaggi!</small></p>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, off } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC6imkgB2bRtUv113tDGFWdeNl-fWq_Oc8",
            authDomain: "scacchi-e4ae1.firebaseapp.com",
            databaseURL: "https://scacchi-e4ae1-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "scacchi-e4ae1",
            storageBucket: "scacchi-e4ae1.firebasestorage.app",
            messagingSenderId: "655013026025",
            appId: "1:655013026025:web:a97e5bf05c7f2e25ba7878"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Rendi Firebase disponibile globalmente
        window.firebaseApp = app;
        window.firebaseDatabase = database;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseGet = get;
        window.firebaseOnValue = onValue;
        window.firebaseOff = off;

        // Test connessione Firebase
        const testRef = ref(database, '.info/connected');
        onValue(testRef, (snapshot) => {
            const connected = snapshot.val();
            updateFirebaseStatus(connected);
            console.log('Firebase Status:', connected ? 'Connected' : 'Disconnected');
        });

        function updateFirebaseStatus(connected) {
            const statusElements = document.querySelectorAll('[id*="firebase-status"], #firebase-connection');
            statusElements.forEach(element => {
                if (connected) {
                    element.textContent = 'üü¢ Firebase Online';
                    element.className = 'connection-status connection-online';
                } else {
                    element.textContent = 'üî¥ Firebase Offline';
                    element.className = 'connection-status connection-offline';
                }
            });
        }

        console.log('üî• Firebase inizializzato con successo!');
    </script>

    <script>
        // Configurazione
        const ADMIN_PASSWORD = 'chess123'; // Password amministratore - CAMBIA QUESTA!
        
        // State dell'applicazione
        let gameState = {
            board: null,
            currentPlayer: 'white',
            gameActive: false,
            selectedSquare: null,
            moveHistory: [],
            players: { white: 'Bianco', black: 'Nero' },
            gameId: null,
            isAdmin: false,
            playerColor: null,
            gameEnded: false,
            castlingRights: {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            },
            enPassantTarget: null,
            halfMoveClock: 0,
            fullMoveNumber: 1
        };

        // Firebase listener attivo
        let currentGameListener = null;

        // Pezzi degli scacchi Unicode
        const chessPieces = {
            'white': {
                'king': '‚ôî', 'queen': '‚ôï', 'rook': '‚ôñ',
                'bishop': '‚ôó', 'knight': '‚ôò', 'pawn': '‚ôô'
            },
            'black': {
                'king': '‚ôö', 'queen': '‚ôõ', 'rook': '‚ôú',
                'bishop': '‚ôù', 'knight': '‚ôû', 'pawn': '‚ôü'
            }
        };

        // Inizializzazione scacchiera
        function initializeBoard() {
            return [
                ['black', 'rook'], ['black', 'knight'], ['black', 'bishop'], ['black', 'queen'],
                ['black', 'king'], ['black', 'bishop'], ['black', 'knight'], ['black', 'rook'],
                ['black', 'pawn'], ['black', 'pawn'], ['black', 'pawn'], ['black', 'pawn'],
                ['black', 'pawn'], ['black', 'pawn'], ['black', 'pawn'], ['black', 'pawn'],
                null, null, null, null, null, null, null, null,
                null, null, null, null, null, null, null, null,
                null, null, null, null, null, null, null, null,
                null, null, null, null, null, null, null, null,
                ['white', 'pawn'], ['white', 'pawn'], ['white', 'pawn'], ['white', 'pawn'],
                ['white', 'pawn'], ['white', 'pawn'], ['white', 'pawn'], ['white', 'pawn'],
                ['white', 'rook'], ['white', 'knight'], ['white', 'bishop'], ['white', 'queen'],
                ['white', 'king'], ['white', 'bishop'], ['white', 'knight'], ['white', 'rook']
            ];
        }

        // FIREBASE FUNCTIONS
        async function saveGameToFirebase() {
            if (!gameState.gameId || !window.firebaseDatabase) {
                console.error('Game ID o Firebase non disponibili');
                return false;
            }

            try {
                const gameRef = window.firebaseRef(window.firebaseDatabase, 'games/' + gameState.gameId);
                
                // Prepara dati ottimizzati per Firebase
                const firebaseData = {
                    board: gameState.board,
                    currentPlayer: gameState.currentPlayer,
                    gameActive: gameState.gameActive,
                    moveHistory: gameState.moveHistory,
                    players: gameState.players,
                    gameEnded: gameState.gameEnded,
                    castlingRights: gameState.castlingRights,
                    enPassantTarget: gameState.enPassantTarget,
                    lastUpdate: Date.now()
                };

                await window.firebaseSet(gameRef, firebaseData);
                console.log('üî• Partita salvata su Firebase:', gameState.gameId);
                return true;
            } catch (error) {
                console.error('Errore salvataggio Firebase:', error);
                showMessage('game-status', 'Errore di connessione al database', 'error');
                return false;
            }
        }

        async function loadGameFromFirebase(gameId) {
            if (!gameId || !window.firebaseDatabase) {
                console.error('Game ID o Firebase non disponibili');
                return false;
            }

            try {
                const gameRef = window.firebaseRef(window.firebaseDatabase, 'games/' + gameId);
                const snapshot = await window.firebaseGet(gameRef);
                
                if (snapshot.exists()) {
                    const firebaseData = snapshot.val();
                    console.log('üî• Partita caricata da Firebase:', gameId);
                    
                    // Aggiorna gameState con i dati Firebase
                    gameState.board = firebaseData.board;
                    gameState.currentPlayer = firebaseData.currentPlayer;
                    gameState.gameActive = firebaseData.gameActive;
                    gameState.moveHistory = firebaseData.moveHistory || [];
                    gameState.players = firebaseData.players || { white: 'Bianco', black: 'Nero' };
                    gameState.gameEnded = firebaseData.gameEnded || false;
                    gameState.castlingRights = firebaseData.castlingRights || {
                        white: { kingside: true, queenside: true },
                        black: { kingside: true, queenside: true }
                    };
                    gameState.enPassantTarget = firebaseData.enPassantTarget || null;
                    gameState.gameId = gameId;
                    
                    return true;
                } else {
                    console.error('Partita non trovata su Firebase:', gameId);
                    return false;
                }
            } catch (error) {
                console.error('Errore caricamento Firebase:', error);
                return false;
            }
        }

        function setupGameListener(gameId) {
            if (!gameId || !window.firebaseDatabase) return;
            
            // Rimuovi listener precedente se esiste
            if (currentGameListener) {
                window.firebaseOff(currentGameListener);
            }

            // Nuovo listener per sincronizzazione real-time
            const gameRef = window.firebaseRef(window.firebaseDatabase, 'games/' + gameId);
            currentGameListener = gameRef;
            
            window.firebaseOnValue(gameRef, (snapshot) => {
                if (snapshot.exists()) {
                    const firebaseData = snapshot.val();
                    
                    // Evita loop infiniti - controlla se √® un aggiornamento esterno
                    if (firebaseData.lastUpdate && firebaseData.lastUpdate !== gameState.lastUpdate) {
                        console.log('üì° Sincronizzazione real-time ricevuta');
                        
                        // Aggiorna stato locale
                        gameState.board = firebaseData.board;
                        gameState.currentPlayer = firebaseData.currentPlayer;
                        gameState.gameActive = firebaseData.gameActive;
                        gameState.moveHistory = firebaseData.moveHistory || [];
                        gameState.gameEnded = firebaseData.gameEnded || false;
                        gameState.castlingRights = firebaseData.castlingRights || gameState.castlingRights;
                        gameState.enPassantTarget = firebaseData.enPassantTarget || null;
                        gameState.lastUpdate = firebaseData.lastUpdate;
                        
                        // Aggiorna interfaccia
                        if (document.getElementById('game-screen').classList.contains('active')) {
                            renderBoard();
                            updateGameInfo();
                            updateMovesHistory();
                            updateCurrentGameLink();
                            
                            // Notifica mossa avversario
                            if (gameState.playerColor && gameState.currentPlayer !== gameState.playerColor) {
                                showMessage('game-status', 'üîÑ L\'avversario ha fatto una mossa!', 'success');
                            }
                        }
                    }
                }
            });
        }

        // Genera URL corto con solo ID partita
        function getGameUrl(gameId) {
            console.log('=== GENERAZIONE URL CORTO FIREBASE ===');
            console.log('Game ID:', gameId);
            
            const baseUrl = window.location.origin + window.location.pathname;
            const shortUrl = baseUrl + '?game=' + gameId;
            
            console.log('URL Firebase (corto):', shortUrl);
            console.log('Lunghezza:', shortUrl.length, 'caratteri');
            
            return shortUrl;
        }

        // Funzioni di utilit√†
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function showMessage(elementId, message, type = 'success') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            // Pulisci i messaggi temporanei dopo 3 secondi (tranne quelli permanenti)
            if (elementId === 'game-status' && (message.includes('Non √® il tuo turno') || message.includes('Puoi muovere solo'))) {
                setTimeout(() => {
                    if (element.innerHTML.includes(message)) {
                        element.innerHTML = '';
                    }
                }, 3000);
            }
        }

        function generateGameId() {
            // ID pi√π corto e leggibile
            return Math.random().toString(36).substr(2, 8).toUpperCase();
        }

        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Login amministratore
        function adminLogin() {
            const password = document.getElementById('admin-password').value;
            if (password === ADMIN_PASSWORD) {
                gameState.isAdmin = true;
                gameState.playerColor = null;
                localStorage.setItem('chessAdminAuth', 'true');
                showAdminPanel();
                showMessage('login-message', 'Accesso effettuato con successo!', 'success');
            } else {
                showMessage('login-message', 'Password non corretta!', 'error');
            }
        }

        function logout() {
            gameState.isAdmin = false;
            gameState.playerColor = null;
            localStorage.removeItem('chessAdminAuth');
            showScreen('admin-login');
            document.getElementById('admin-password').value = '';
        }

        // Pannello amministratore
        function showAdminPanel() {
            showScreen('admin-panel');
        }

        async function createGame() {
            const whiteName = document.getElementById('white-player').value || 'Bianco';
            const blackName = document.getElementById('black-player').value || 'Nero';

            // Crea nuova partita
            gameState.gameId = generateGameId();
            gameState.players.white = whiteName;
            gameState.players.black = blackName;
            gameState.board = initializeBoard();
            gameState.currentPlayer = 'white';
            gameState.gameActive = true;
            gameState.gameEnded = false;
            gameState.moveHistory = [];
            gameState.selectedSquare = null;
            gameState.playerColor = 'white'; // L'admin che crea la partita gioca con i bianchi
            gameState.castlingRights = {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            };
            gameState.enPassantTarget = null;
            gameState.lastUpdate = Date.now();

            // Salva su Firebase
            const saved = await saveGameToFirebase();
            
            if (saved) {
                // Setup real-time listener
                setupGameListener(gameState.gameId);
                
                // Mostra il link da condividere
                const gameUrl = getGameUrl(gameState.gameId);
                showGameLink(gameUrl, whiteName, blackName);
            } else {
                showMessage('admin-message', 'Errore nella creazione della partita. Controlla la connessione Firebase.', 'error');
            }
        }

        function showGameLink(gameUrl, whiteName, blackName) {
            const urlLength = gameUrl.length;
            
            const linkMessage = `
                <div class="status-message status-success">
                    <h4>üéâ Partita Creata!</h4>
                    <p><strong>üî• Firebase Attivato!</strong></p>
                    <p><strong>Giocatori:</strong></p>
                    <p>‚Ä¢ Bianco: ${whiteName} (Tu - Admin)</p>
                    <p>‚Ä¢ Nero: ${blackName} (Avversario)</p>
                    <div class="game-link">
                        <strong>üöÄ Link Super-Corto (${urlLength} caratteri):</strong><br>
                        <input type="text" value="${gameUrl}" readonly onclick="this.select()" style="width:100%; padding:8px; margin:5px 0; font-family:monospace; background:#f8f9fa; border:1px solid #ddd; border-radius:4px;">
                    </div>
                    <p><em>üí° Copia il link sopra e invialo all'avversario.</em></p>
                    <p><em>‚ú® La partita si sincronizza automaticamente su tutti i dispositivi!</em></p>
                    <button class="btn" onclick="showGame()" style="margin-top:10px;">Inizia a Giocare (come Bianco)</button>
                </div>
            `;
            
            showMessage('admin-message', linkMessage, 'success');
        }

        async function showGameIfExists() {
            if (gameState.gameActive && gameState.gameId) {
                // Ricarica dalla Firebase per essere sicuri
                const loaded = await loadGameFromFirebase(gameState.gameId);
                if (loaded) {
                    gameState.playerColor = 'white';
                    gameState.isAdmin = true;
                    setupGameListener(gameState.gameId);
                    showGame();
                } else {
                    showMessage('admin-message', 'Errore nel caricamento della partita da Firebase!', 'error');
                }
            } else {
                showMessage('admin-message', 'Nessuna partita attiva!', 'warning');
            }
        }

        async function resetGame() {
            if (!gameState.isAdmin) {
                showMessage('game-status', 'Solo l\'amministratore pu√≤ resettare la partita!', 'error');
                return;
            }

            if (confirm('Sei sicuro di voler resettare la partita? Tutti i dati verranno cancellati.')) {
                // Rimuovi listener Firebase
                if (currentGameListener) {
                    window.firebaseOff(currentGameListener);
                    currentGameListener = null;
                }

                // Cancella da Firebase se esiste un gameId
                if (gameState.gameId && window.firebaseDatabase) {
                    try {
                        const gameRef = window.firebaseRef(window.firebaseDatabase, 'games/' + gameState.gameId);
                        await window.firebaseSet(gameRef, null); // Cancella il nodo
                        console.log('üî• Partita cancellata da Firebase');
                    } catch (error) {
                        console.error('Errore cancellazione Firebase:', error);
                    }
                }
                
                // Cancella stato locale
                localStorage.removeItem('chessGameState');
                
                // Reset stato globale preservando admin status
                gameState = {
                    board: null,
                    currentPlayer: 'white',
                    gameActive: false,
                    selectedSquare: null,
                    moveHistory: [],
                    players: { white: 'Bianco', black: 'Nero' },
                    gameId: null,
                    isAdmin: true,
                    playerColor: null,
                    gameEnded: false,
                    castlingRights: {
                        white: { kingside: true, queenside: true },
                        black: { kingside: true, queenside: true }
                    },
                    enPassantTarget: null,
                    halfMoveClock: 0,
                    fullMoveNumber: 1
                };

                showAdminPanel();
                showMessage('admin-message', 'Partita resettata con successo!', 'success');
            }
        }

        function showGame() {
            if (!gameState.gameActive) {
                showScreen('error-screen');
                document.getElementById('error-message').textContent = 'Nessuna partita attiva.';
                return;
            }

            // Se √® l'admin e non ha un colore assegnato, gli assegna il bianco
            if (gameState.isAdmin && !gameState.playerColor) {
                gameState.playerColor = 'white';
            }

            showScreen('game-screen');
            document.getElementById('white-name').textContent = gameState.players.white;
            document.getElementById('black-name').textContent = gameState.players.black;
            
            // Mostra controlli admin se √® amministratore
            if (gameState.isAdmin) {
                document.getElementById('admin-controls').style.display = 'block';
            } else {
                document.getElementById('admin-controls').style.display = 'none';
            }

            // Aggiorna il link corrente sempre visibile
            updateCurrentGameLink();

            renderBoard();
            updateGameInfo();
            updateMovesHistory();
        }

        function renderBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const index = row * 8 + col;
                    const isWhiteSquare = (row + col) % 2 === 0;
                    
                    square.className = `square ${isWhiteSquare ? 'white' : 'black'}`;
                    square.dataset.index = index;
                    square.onclick = () => handleSquareClick(index);

                    // Aggiungi pezzo se presente
                    if (gameState.board[index]) {
                        const [color, piece] = gameState.board[index];
                        square.textContent = chessPieces[color][piece];
                        
                        // Aggiungi classe per pezzi non giocabili
                        if (gameState.playerColor && color !== gameState.playerColor) {
                            square.classList.add('not-playable');
                        }
                    }

                    board.appendChild(square);
                }
            }
        }

        function handleSquareClick(index) {
            if (!gameState.gameActive || gameState.gameEnded) return;

            // Controlla se il giocatore pu√≤ fare mosse
            if (!canPlayerMove()) {
                showMessage('game-status', 'Non √® il tuo turno! Attendi che giochi l\'avversario.', 'warning');
                return;
            }

            // Rimuovi evidenziazioni precedenti
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move', 'possible-capture');
            });

            const piece = gameState.board[index];
            
            if (gameState.selectedSquare === null) {
                // Selezione pezzo - pu√≤ selezionare solo i propri pezzi
                if (piece && piece[0] === gameState.currentPlayer && piece[0] === gameState.playerColor) {
                    gameState.selectedSquare = index;
                    document.querySelector(`[data-index="${index}"]`).classList.add('selected');
                    highlightPossibleMoves(index);
                } else if (piece && piece[0] !== gameState.playerColor) {
                    showMessage('game-status', 'Puoi muovere solo i tuoi pezzi!', 'warning');
                }
            } else {
                // Tentativo di mossa
                if (gameState.selectedSquare === index) {
                    // Deseleziona
                    gameState.selectedSquare = null;
                } else if (isValidMove(gameState.selectedSquare, index)) {
                    makeMove(gameState.selectedSquare, index);
                    gameState.selectedSquare = null;
                } else {
                    // Seleziona nuovo pezzo se del colore giusto
                    if (piece && piece[0] === gameState.currentPlayer && piece[0] === gameState.playerColor) {
                        gameState.selectedSquare = index;
                        document.querySelector(`[data-index="${index}"]`).classList.add('selected');
                        highlightPossibleMoves(index);
                    } else {
                        gameState.selectedSquare = null;
                        if (piece && piece[0] !== gameState.playerColor) {
                            showMessage('game-status', 'Puoi muovere solo i tuoi pezzi!', 'warning');
                        }
                    }
                }
            }
        }

        function canPlayerMove() {
            if (!gameState.playerColor) return false;
            return gameState.playerColor === gameState.currentPlayer;
        }

        function highlightPossibleMoves(fromIndex) {
            const possibleMoves = getAllValidMovesForPiece(fromIndex);
            const piece = gameState.board[fromIndex];
            
            possibleMoves.forEach(toIndex => {
                const targetPiece = gameState.board[toIndex];
                const squareElement = document.querySelector(`[data-index="${toIndex}"]`);
                
                // Controlla se √® una mossa di cattura
                const isCapture = isCapturingMove(fromIndex, toIndex, piece, targetPiece);
                
                if (isCapture) {
                    squareElement.classList.add('possible-capture');
                } else {
                    squareElement.classList.add('possible-move');
                }
            });
        }

        function isCapturingMove(fromIndex, toIndex, piece, targetPiece) {
            // Cattura diretta
            if (targetPiece && targetPiece[0] !== piece[0]) {
                return true;
            }
            
            // En passant
            if (piece[1] === 'pawn' && gameState.enPassantTarget === toIndex) {
                return true;
            }
            
            return false;
        }

        function getAllValidMovesForPiece(index) {
            const moves = [];
            for (let i = 0; i < 64; i++) {
                if (isValidMove(index, i)) {
                    moves.push(i);
                }
            }
            return moves;
        }

        function isValidMove(from, to) {
            if (from === to) return false;
            
            const piece = gameState.board[from];
            if (!piece || piece[0] !== gameState.currentPlayer) return false;

            const targetPiece = gameState.board[to];
            if (targetPiece && targetPiece[0] === gameState.currentPlayer) return false;

            const [color, pieceType] = piece;
            const fromRow = Math.floor(from / 8);
            const fromCol = from % 8;
            const toRow = Math.floor(to / 8);
            const toCol = to % 8;
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;

            // Logica specifica per ogni tipo di pezzo
            switch (pieceType) {
                case 'pawn':
                    return isValidPawnMove(from, to, color, rowDiff, colDiff, targetPiece);
                case 'rook':
                    return isValidRookMove(from, to, rowDiff, colDiff);
                case 'bishop':
                    return isValidBishopMove(from, to, rowDiff, colDiff);
                case 'queen':
                    return isValidQueenMove(from, to, rowDiff, colDiff);
                case 'knight':
                    return isValidKnightMove(rowDiff, colDiff);
                case 'king':
                    return isValidKingMove(from, to, color, rowDiff, colDiff);
                default:
                    return false;
            }
        }

        // [Continuano tutte le funzioni di validazione mosse - identiche a prima...]
        function isValidPawnMove(from, to, color, rowDiff, colDiff, targetPiece) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const fromRow = Math.floor(from / 8);

            if (colDiff === 0 && !targetPiece) {
                if (rowDiff === direction) return true;
                if (fromRow === startRow && rowDiff === 2 * direction) return true;
            }
            
            if (Math.abs(colDiff) === 1 && rowDiff === direction) {
                if (targetPiece) return true;
                if (gameState.enPassantTarget === to) return true;
            }

            return false;
        }

        function isValidRookMove(from, to, rowDiff, colDiff) {
            if (rowDiff !== 0 && colDiff !== 0) return false;
            return isPathClear(from, to);
        }

        function isValidBishopMove(from, to, rowDiff, colDiff) {
            if (Math.abs(rowDiff) !== Math.abs(colDiff)) return false;
            return isPathClear(from, to);
        }

        function isValidQueenMove(from, to, rowDiff, colDiff) {
            return isValidRookMove(from, to, rowDiff, colDiff) || 
                   isValidBishopMove(from, to, rowDiff, colDiff);
        }

        function isValidKnightMove(rowDiff, colDiff) {
            return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                   (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);
        }

        function isValidKingMove(from, to, color, rowDiff, colDiff) {
            if (Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1) {
                return true;
            }
            
            if (rowDiff === 0 && Math.abs(colDiff) === 2) {
                return canCastle(color, colDiff > 0);
            }

            return false;
        }

        function canCastle(color, kingside) {
            const row = color === 'white' ? 7 : 0;
            const kingPos = row * 8 + 4;
            const rookPos = kingside ? row * 8 + 7 : row * 8;

            if (!gameState.castlingRights[color][kingside ? 'kingside' : 'queenside']) {
                return false;
            }

            if (!gameState.board[kingPos] || gameState.board[kingPos][1] !== 'king') return false;
            if (!gameState.board[rookPos] || gameState.board[rookPos][1] !== 'rook') return false;

            const startCol = kingside ? 5 : 1;
            const endCol = kingside ? 6 : 3;
            for (let col = startCol; col <= endCol; col++) {
                if (gameState.board[row * 8 + col]) return false;
            }

            return true;
        }

        function isPathClear(from, to) {
            const fromRow = Math.floor(from / 8);
            const fromCol = from % 8;
            const toRow = Math.floor(to / 8);
            const toCol = to % 8;

            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                const index = currentRow * 8 + currentCol;
                if (gameState.board[index]) return false;
                
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        async function makeMove(from, to) {
            const piece = gameState.board[from];
            const targetPiece = gameState.board[to];
            const [color, pieceType] = piece;

            console.log('=== MAKING MOVE ===');
            console.log('From:', from, 'To:', to);
            console.log('Piece:', piece);

            // Salva mossa nella cronologia
            const moveNotation = getMoveNotation(from, to, piece, targetPiece);
            gameState.moveHistory.push(moveNotation);

            // Esegui la mossa
            gameState.board[to] = piece;
            gameState.board[from] = null;

            // Aggiorna diritti di arrocco
            updateCastlingRights(from, to, piece);

            // Gestisci mosse speciali
            const hasPromotion = handleSpecialMoves(from, to, piece);

            if (hasPromotion) {
                // La promozione sar√† completata dopo la scelta dell'utente
                console.log('Promozione in corso - aspettando scelta utente');
                return;
            }

            // Completa la mossa normalmente
            await completeMove();
        }

        async function completeMove() {
            // Cambia turno
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            gameState.lastUpdate = Date.now();

            // Salva su Firebase
            const saved = await saveGameToFirebase();
            
            if (saved) {
                renderBoard();
                updateGameInfo();
                updateMovesHistory();
                updateCurrentGameLink();
                showMessage('game-status', 'üîÑ Mossa effettuata! Sincronizzazione con Firebase completata.', 'success');
                checkGameEnd();
            } else {
                showMessage('game-status', 'Errore nel salvare la mossa. Riprova.', 'error');
            }
        }

        // [Continuano tutte le altre funzioni di supporto - identiche...]
        function updateCastlingRights(from, to, piece) {
            const [color, pieceType] = piece;

            if (pieceType === 'king') {
                gameState.castlingRights[color].kingside = false;
                gameState.castlingRights[color].queenside = false;
            }

            if (pieceType === 'rook') {
                const row = color === 'white' ? 7 : 0;
                if (from === row * 8 + 7) {
                    gameState.castlingRights[color].kingside = false;
                }
                if (from === row * 8) {
                    gameState.castlingRights[color].queenside = false;
                }
            }

            const toRow = Math.floor(to / 8);
            const toCol = to % 8;
            if ((toRow === 0 || toRow === 7) && (toCol === 0 || toCol === 7)) {
                const capturedColor = toRow === 0 ? 'black' : 'white';
                if (toCol === 0) {
                    gameState.castlingRights[capturedColor].queenside = false;
                } else {
                    gameState.castlingRights[capturedColor].kingside = false;
                }
            }
        }

        function handleSpecialMoves(from, to, piece) {
            const [color, pieceType] = piece;
            const fromRow = Math.floor(from / 8);
            const toRow = Math.floor(to / 8);
            const colDiff = (to % 8) - (from % 8);

            // Arrocco
            if (pieceType === 'king' && Math.abs(colDiff) === 2) {
                const row = color === 'white' ? 7 : 0;
                const rookFromCol = colDiff > 0 ? 7 : 0;
                const rookToCol = colDiff > 0 ? 5 : 3;
                
                gameState.board[row * 8 + rookToCol] = gameState.board[row * 8 + rookFromCol];
                gameState.board[row * 8 + rookFromCol] = null;
            }

            // En passant
            if (pieceType === 'pawn' && gameState.enPassantTarget === to) {
                const capturedPawnRow = color === 'white' ? toRow + 1 : toRow - 1;
                gameState.board[capturedPawnRow * 8 + (to % 8)] = null;
            }

            // Imposta target en passant
            if (pieceType === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                gameState.enPassantTarget = fromRow + (toRow - fromRow) / 2;
                gameState.enPassantTarget = gameState.enPassantTarget * 8 + (to % 8);
            } else {
                gameState.enPassantTarget = null;
            }

            // Promozione pedone
            if (pieceType === 'pawn' && (toRow === 0 || toRow === 7)) {
                promotionData = {
                    position: to,
                    color: color
                };
                showPromotionModal(color);
                return true;
            }

            return false;
        }

        // Variabile per gestire la promozione
        let promotionData = null;

        function showPromotionModal(color) {
            const modal = document.getElementById('promotion-modal');
            
            document.getElementById('promotion-queen').textContent = chessPieces[color]['queen'];
            document.getElementById('promotion-rook').textContent = chessPieces[color]['rook'];
            document.getElementById('promotion-bishop').textContent = chessPieces[color]['bishop'];
            document.getElementById('promotion-knight').textContent = chessPieces[color]['knight'];
            
            modal.classList.add('active');
        }

        async function promoteTopiece(pieceType) {
            if (!promotionData) return;
            
            gameState.board[promotionData.position] = [promotionData.color, pieceType];
            
            document.getElementById('promotion-modal').classList.remove('active');
            promotionData = null;
            
            await completeMove();
        }

        function getMoveNotation(from, to, piece, targetPiece) {
            const fromCol = String.fromCharCode(97 + (from % 8));
            const fromRow = 8 - Math.floor(from / 8);
            const toCol = String.fromCharCode(97 + (to % 8));
            const toRow = 8 - Math.floor(to / 8);
            
            let notation = '';
            if (piece[1] !== 'pawn') {
                notation += piece[1].charAt(0).toUpperCase();
            }
            
            notation += fromCol + fromRow;
            notation += targetPiece ? 'x' : '-';
            notation += toCol + toRow;
            
            return notation;
        }

        function updateGameInfo() {
            const currentPlayerName = gameState.players[gameState.currentPlayer];
            let turnInfo = `Turno di ${currentPlayerName}`;
            
            if (gameState.playerColor) {
                const myColor = gameState.playerColor === 'white' ? 'Bianco' : 'Nero';
                const roleInfo = gameState.isAdmin ? ' (Admin)' : ' (Invitato)';
                
                if (gameState.playerColor === gameState.currentPlayer) {
                    turnInfo += ` - üéØ √à il tuo turno! (Tu: ${myColor}${roleInfo})`;
                } else {
                    turnInfo += ` - ‚è≥ Aspetta il tuo turno (Tu: ${myColor}${roleInfo})`;
                }
            }
            
            document.getElementById('current-turn').textContent = turnInfo;
            
            if (gameState.gameEnded) {
                document.getElementById('game-status').innerHTML = '<div class="status-message status-warning">Partita terminata</div>';
            } else if (!canPlayerMove() && gameState.playerColor) {
                // Non mostra messaggio se non √® il proprio turno (evita spam)
            }
        }

        function updateMovesHistory() {
            const movesList = document.getElementById('moves-list');
            if (gameState.moveHistory.length === 0) {
                movesList.innerHTML = '<p>Nessuna mossa ancora effettuata.</p>';
                return;
            }

            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">';
            for (let i = 0; i < gameState.moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = gameState.moveHistory[i] || '';
                const blackMove = gameState.moveHistory[i + 1] || '';
                html += `<div><strong>${moveNumber}.</strong> ${whiteMove} ${blackMove}</div>`;
            }
            html += '</div>';
            movesList.innerHTML = html;
        }

        function updateCurrentGameLink() {
            const linkField = document.getElementById('current-game-url');
            const infoElement = document.getElementById('url-info');
            
            if (linkField && gameState.gameActive && gameState.gameId) {
                const currentUrl = getGameUrl(gameState.gameId);
                linkField.value = currentUrl;
                
                if (infoElement) {
                    const urlLength = currentUrl.length;
                    infoElement.innerHTML = `<em>üöÄ URL Firebase: ${urlLength} caratteri - Permanente & Cross-device!</em>`;
                }
            }
        }

        function copyCurrentLink() {
            const linkField = document.getElementById('current-game-url');
            if (linkField && linkField.value) {
                linkField.select();
                linkField.setSelectionRange(0, 99999); // Per mobile
                
                try {
                    document.execCommand('copy');
                    showMessage('game-status', 'üìã Link Firebase copiato! La partita si sincronizzer√† automaticamente.', 'success');
                } catch (err) {
                    console.error('Errore copia:', err);
                    showMessage('game-status', 'Seleziona e copia manualmente il link sopra', 'warning');
                }
                
                setTimeout(() => {
                    updateGameInfo();
                }, 3000);
            }
        }

        function checkGameEnd() {
            // Implementazione futura per scacco matto
        }

        async function endGame(result) {
            if (!gameState.isAdmin) {
                showMessage('game-status', 'Solo l\'amministratore pu√≤ terminare la partita!', 'error');
                return;
            }

            gameState.gameEnded = true;
            let resultText = '';
            
            switch (result) {
                case 'white':
                    resultText = `Vittoria di ${gameState.players.white}!`;
                    break;
                case 'black':
                    resultText = `Vittoria di ${gameState.players.black}!`;
                    break;
                case 'draw':
                    resultText = 'Partita patta!';
                    break;
                case 'abandoned':
                    resultText = 'Partita abbandonata.';
                    break;
            }

            document.getElementById('game-status').innerHTML = 
                `<div class="status-message status-success">${resultText}</div>`;
            
            // Salva stato finale su Firebase
            await saveGameToFirebase();
        }

        // Inizializzazione applicazione
        async function initializeApp() {
            // Controlla se c'√® un game ID nell'URL
            const gameId = getUrlParameter('game');
            
            console.log('=== INIZIALIZZAZIONE APP FIREBASE ===');
            console.log('Game ID dall\'URL:', gameId);
            
            if (gameId) {
                // Accesso tramite link partita
                showScreen('loading-screen');
                
                setTimeout(async () => {
                    const gameLoaded = await loadGameFromFirebase(gameId);
                    
                    if (gameLoaded && gameState.gameActive) {
                        console.log('üî• Partita caricata da Firebase');
                        
                        // Determina il ruolo del giocatore in base al turno corrente
                        if (gameState.currentPlayer === 'white') {
                            gameState.playerColor = 'white';
                            gameState.isAdmin = true;
                            console.log('üéØ Assegnato BIANCO/Admin');
                        } else {
                            gameState.playerColor = 'black';  
                            gameState.isAdmin = false;
                            console.log('üéØ Assegnato NERO/Invitato');
                        }
                        
                        // Setup real-time listener
                        setupGameListener(gameId);
                        
                        showGame();
                        
                    } else {
                        console.log('‚ùå Errore caricamento partita Firebase');
                        showScreen('error-screen');
                        document.getElementById('error-message').textContent = 'Partita non trovata su Firebase o non pi√π attiva.';
                    }
                }, 1000);
            } else {
                // Accesso diretto - controlla se √® admin salvato
                const savedAdmin = localStorage.getItem('chessAdminAuth');
                
                if (savedAdmin === 'true') {
                    gameState.isAdmin = true;
                    showAdminPanel();
                } else {
                    showScreen('admin-login');
                }
            }
        }

        // Avvia applicazione quando Firebase √® pronto
        window.addEventListener('load', () => {
            // Aspetta un momento per essere sicuri che Firebase sia inizializzato
            setTimeout(initializeApp, 500);
        });

        // Gestione chiusura pagina
        window.addEventListener('beforeunload', function() {
            if (currentGameListener) {
                window.firebaseOff(currentGameListener);
            }
        });
    </script>
</body>
</html>